use crate::domain::callgraph::*;
use crate::ports::{CallGraphBuilder, OutputExporter};
use syn::{File, Item, Expr, Stmt};
use std::collections::HashMap;
use std::fs;

pub struct SimpleCallGraphBuilder;

impl CallGraphBuilder for SimpleCallGraphBuilder {
    fn build_call_graph(&self, sources: &[(String, String, String)]) -> CallGraph {
        use std::collections::HashMap;
        let mut func_defs: Vec<(String, String, String, Vec<String>)> = vec![];
        for (crate_name, path, code) in sources {
            let ast_file: syn::File = match syn::parse_file(code) {
                Ok(f) => f,
                Err(_) => continue,
            };
            for item in ast_file.items {
                if let syn::Item::Fn(ref func) = item {
                    let name = func.sig.ident.to_string();
                    let mut callees = vec![];
                    visit_stmts(&func.block.stmts, &mut callees);
                    println!("[DEBUG][insert] fn={} crate={} path={} callees={:?}", name, crate_name, path, callees);
                    func_defs.push((name, crate_name.clone(), path.clone(), callees));
                }
            }
        }
        /* 構建所有 id -> (crate, path) 對應表 */
        let mut id_map: HashMap<String, (String, String, String)> = HashMap::new();
        for (name, crate_name, path, _) in &func_defs {
            let id = format!("{}@{}", name, crate_name);
            id_map.insert(id, (name.clone(), crate_name.clone(), path.clone()));
        }
        /* 產生 callgraph nodes，並 resolve callee id */
        let mut nodes = vec![];
        for (name, crate_name, path, callees) in &func_defs {
            let id = format!("{}@{}", name, crate_name);
            let callee_ids = callees.iter().filter_map(|callee_name| {
                if callee_name.contains("::") {
                    let parts: Vec<&str> = callee_name.split("::").collect();
                    if parts.len() == 2 {
                        let search_id = format!("{}@{}", parts[1], parts[0]);
                        println!("[DEBUG][resolve] parts: {:?} -> search_id={}", parts, search_id);
                        if id_map.contains_key(&search_id) {
                            Some(search_id)
                        } else {
                            None
                        }
                    } else { None }
                } else {
                    let search_id = format!("{}@{}", callee_name, crate_name);
                    if id_map.contains_key(&search_id) {
                        Some(search_id)
                    } else {
                        None
                    }
                }
            }).collect();
            nodes.push(CallGraphNode {
                id,
                callees: callee_ids,
            });
        }
        CallGraph { nodes }
    }
}
            });
        }
        CallGraph { nodes }
    }
}

fn visit_stmts(stmts: &[Stmt], callees: &mut Vec<String>) {
    for stmt in stmts {
        match stmt {
            Stmt::Expr(expr, _) => visit_expr(expr, callees),
            _ => {}
        }
    }
}

fn visit_expr(expr: &Expr, callees: &mut Vec<String>) {
    match expr {
        Expr::Call(expr_call) => {
            if let Expr::Path(ref expr_path) = *expr_call.func {
                let segments: Vec<_> = expr_path.path.segments.iter().map(|s| s.ident.to_string()).collect();
                if !segments.is_empty() {
println!("[DEBUG] Detected call: {}", segments.join("::"));
                    callees.push(segments.join("::"));
                }
            }
            for arg in &expr_call.args {
                visit_expr(arg, callees);
            }
        }
        Expr::Block(expr_block) => visit_stmts(&expr_block.block.stmts, callees),
        _ => {}
    }
}

pub struct DotExporter;
impl OutputExporter for DotExporter {
    fn export(&self, cg: &CallGraph, path: &str) -> std::io::Result<()> {
        let mut lines = vec!["digraph G {".to_string()];
        for node in &cg.nodes {
            lines.push(format!("    \"{}\";", node.id));
            for callee in &node.callees {
                lines.push(format!("    \"{}\" -> \"{}\";", node.id, callee));
            }
        }
        lines.push("}".to_string());
        fs::write(path, lines.join("\n"))
    }
}
