use crate::domain::callgraph::*;
use crate::ports::{CallGraphBuilder, OutputExporter};
use syn::{File, Item, Expr, Stmt};
use std::collections::HashMap;
use std::fs;

pub struct SimpleCallGraphBuilder;

impl CallGraphBuilder for SimpleCallGraphBuilder {
    fn build_call_graph(&self, sources: &[(String, String, String)]) -> CallGraph {
        let mut funcs: HashMap<(String, String, String), Vec<String>> = HashMap::new();
        for (crate_name, path, code) in sources {
            let ast_file: File = match syn::parse_file(code) {
                Ok(f) => f,
                Err(_) => continue,
            };
            for item in ast_file.items {
                if let Item::Fn(ref func) = item {
                    let name = func.sig.ident.to_string();
                    let crate_name = crate_name.clone();
                    let mut callees = vec![];
                    visit_stmts(&func.block.stmts, &mut callees);
                    funcs.insert((name.clone(), crate_name.clone(), path.clone()), callees);
                }
            }
        }
        let mut nodes = vec![];
        for ((name, crate_name, path), callees) in &funcs {
            nodes.push(CallGraphNode {
                id: format!("{}@{}@{}", name, crate_name, path),
                callees: callees.iter().filter_map(|callee_name| {
                    funcs.keys().find(|(n, _, _)| n == callee_name).map(|(n, c, p)| format!("{}@{}@{}", n, c, p))
                }).collect(),
            });
        }
        CallGraph { nodes }
    }
}

fn visit_stmts(stmts: &[Stmt], callees: &mut Vec<String>) {
    for stmt in stmts {
        match stmt {
            Stmt::Expr(expr, _) => visit_expr(expr, callees),
            _ => {}
        }
    }
}

fn visit_expr(expr: &Expr, callees: &mut Vec<String>) {
    match expr {
        Expr::Call(expr_call) => {
            if let Expr::Path(ref expr_path) = *expr_call.func {
                let segments: Vec<_> = expr_path.path.segments.iter().map(|s| s.ident.to_string()).collect();
                if !segments.is_empty() {
println!("[DEBUG] Detected call: {}", segments.join("::"));
                    callees.push(segments.join("::"));
                }
            }
            for arg in &expr_call.args {
                visit_expr(arg, callees);
            }
        }
        Expr::Block(expr_block) => visit_stmts(&expr_block.block.stmts, callees),
        _ => {}
    }
}

pub struct DotExporter;
impl OutputExporter for DotExporter {
    fn export(&self, cg: &CallGraph, path: &str) -> std::io::Result<()> {
        let mut lines = vec!["digraph G {".to_string()];
        for node in &cg.nodes {
            lines.push(format!("    \"{}\";", node.id));
            for callee in &node.callees {
                lines.push(format!("    \"{}\" -> \"{}\";", node.id, callee));
            }
        }
        lines.push("}".to_string());
        fs::write(path, lines.join("\n"))
    }
}
